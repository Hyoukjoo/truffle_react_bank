{"ast":null,"code":"var _regeneratorRuntime = require(\"c:\\\\Users\\\\judam\\\\Documents\\\\HJ\\\\dev\\\\truffle_react\\\\client\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"c:\\\\Users\\\\judam\\\\Documents\\\\HJ\\\\dev\\\\truffle_react\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar Reason = require('./reason');\n\nvar handlers = require('./handlers');\n\nvar override = {\n  timeoutMessage: 'not mined within',\n  // Substring of timeout err fired by web3\n  defaultMaxBlocks: 50,\n  // Max # of blocks web3 will wait for a tx\n  pollingInterval: 1000,\n\n  /**\n   * Attempts to extract receipt object from Web3 error message\n   * @param  {Object} message       web3 error\n   * @return {Object|undefined} receipt\n   */\n  extractReceipt: function extractReceipt(message) {\n    var hasReceipt = message && message.includes('{');\n    message.includes('}');\n\n    if (hasReceipt) {\n      var receiptString = '{' + message.split('{')[1].trim();\n\n      try {\n        return JSON.parse(receiptString);\n      } catch (err) {// ignore\n      }\n    }\n  },\n\n  /**\n   * Fired after web3 ceases to support subscriptions if user has specified\n   * a higher block wait time than web3's 50 blocks limit. Opens a subscription to listen\n   * for new blocks and begins evaluating whether block height has reached the user\n   * defined timeout threshhold. Resolves either a contract instance or a transaction receipt.\n   *\n   * @param  {Object} context execution state\n   * @param  {Object} err     error\n   */\n  start: function () {\n    var _start = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2(context, web3Error) {\n      var constructor, blockNumber, currentBlock, maxBlocks, timedOut, shouldWait, receipt, reason, listener, currentPollingBlock, pollID;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              constructor = this;\n              blockNumber = null;\n              currentBlock = override.defaultMaxBlocks;\n              maxBlocks = constructor.timeoutBlocks;\n              timedOut = web3Error.message && web3Error.message.includes(override.timeoutMessage);\n              shouldWait = maxBlocks > currentBlock; // Reject after attempting to get reason string if we shouldn't be waiting.\n\n              if (!(!timedOut || !shouldWait)) {\n                _context2.next = 17;\n                break;\n              }\n\n              // We might have been routed here in web3 >= beta.34 by their own status check\n              // error. We want to extract the receipt, emit a receipt event\n              // and reject it ourselves.\n              receipt = override.extractReceipt(web3Error.message);\n\n              if (!receipt) {\n                _context2.next = 12;\n                break;\n              }\n\n              _context2.next = 11;\n              return handlers.receipt(context, receipt);\n\n            case 11:\n              return _context2.abrupt(\"return\");\n\n            case 12:\n              _context2.next = 14;\n              return Reason.get(context.params, constructor.web3);\n\n            case 14:\n              reason = _context2.sent;\n\n              if (reason) {\n                web3Error.reason = reason;\n                web3Error.message += \" -- Reason given: \".concat(reason, \".\");\n              }\n\n              return _context2.abrupt(\"return\", context.promiEvent.reject(web3Error));\n\n            case 17:\n              // This will run every block from now until contract.timeoutBlocks\n              listener = function listener(pollID) {\n                var self = this;\n                currentBlock++;\n\n                if (currentBlock > constructor.timeoutBlocks) {\n                  clearInterval(pollID);\n                  return;\n                }\n\n                constructor.web3.eth.getTransactionReceipt(context.transactionHash).then(function (result) {\n                  if (!result) return;\n                  result.contractAddress ? constructor.at(result.contractAddress).then(context.promiEvent.resolve).catch(context.promiEvent.reject) : constructor.promiEvent.resolve(result);\n                }).catch(function (err) {\n                  clearInterval(pollID);\n                  context.promiEvent.reject(err);\n                });\n              }; // Start polling\n\n\n              _context2.next = 20;\n              return constructor.web3.eth.getBlockNumber();\n\n            case 20:\n              currentPollingBlock = _context2.sent;\n              pollID = setInterval(\n              /*#__PURE__*/\n              _asyncToGenerator(\n              /*#__PURE__*/\n              _regeneratorRuntime.mark(function _callee() {\n                var newBlock;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.next = 2;\n                        return constructor.web3.eth.getBlockNumber();\n\n                      case 2:\n                        newBlock = _context.sent;\n\n                        if (newBlock > currentPollingBlock) {\n                          currentPollingBlock = newBlock;\n                          listener(pollID);\n                        }\n\n                      case 4:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, this);\n              })), override.pollingInterval);\n\n            case 22:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    return function start(_x, _x2) {\n      return _start.apply(this, arguments);\n    };\n  }()\n};\nmodule.exports = override;","map":null,"metadata":{},"sourceType":"script"}