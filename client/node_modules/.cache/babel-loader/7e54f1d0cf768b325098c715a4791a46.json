{"ast":null,"code":"var Web3 = require('web3');\n\nvar abi = require(\"web3-eth-abi\");\n\nvar reformat = require('./reformat');\n\nvar web3 = new Web3();\nvar Utils = {\n  is_object: function is_object(val) {\n    return typeof val == \"object\" && !Array.isArray(val);\n  },\n  is_big_number: function is_big_number(val) {\n    if (typeof val != \"object\") return false;\n    return web3.utils.isBN(val) || web3.utils.isBigNumber(val);\n  },\n  decodeLogs: function decodeLogs(_logs, isSingle) {\n    var constructor = this;\n    var logs = Utils.toTruffleLog(_logs, isSingle);\n    return logs.map(function (log) {\n      var logABI = constructor.events[log.topics[0]];\n\n      if (logABI == null) {\n        return null;\n      }\n\n      var copy = Utils.merge({}, log);\n      copy.event = logABI.name;\n      copy.topics = logABI.anonymous ? copy.topics : copy.topics.slice(1);\n      var logArgs = abi.decodeLog(logABI.inputs, copy.data, copy.topics);\n      copy.args = reformat.numbers.call(constructor, logArgs, logABI.inputs);\n      delete copy.data;\n      delete copy.topics;\n      return copy;\n    }).filter(function (log) {\n      return log != null;\n    });\n  },\n  toTruffleLog: function toTruffleLog(events, isSingle) {\n    // Transform singletons (from event listeners) to the kind of\n    // object we find on the receipt\n    if (isSingle && typeof isSingle === 'boolean') {\n      var temp = [];\n      temp.push(events);\n      return temp.map(function (log) {\n        log.data = log.raw.data;\n        log.topics = log.raw.topics;\n        return log;\n      });\n    } // Or reformat items in the existing array\n\n\n    events.forEach(function (event) {\n      if (event.raw) {\n        event.data = event.raw.data;\n        event.topics = event.raw.topics;\n      }\n    });\n    return events;\n  },\n  merge: function merge() {\n    var merged = {};\n    var args = Array.prototype.slice.call(arguments);\n\n    for (var i = 0; i < args.length; i++) {\n      var object = args[i];\n      var keys = Object.keys(object);\n\n      for (var j = 0; j < keys.length; j++) {\n        var key = keys[j];\n        var value = object[key];\n        merged[key] = value;\n      }\n    }\n\n    return merged;\n  },\n  parallel: function parallel(arr, callback) {\n    callback = callback || function () {};\n\n    if (!arr.length) {\n      return callback(null, []);\n    }\n\n    var index = 0;\n    var results = new Array(arr.length);\n    arr.forEach(function (fn, position) {\n      fn(function (err, result) {\n        if (err) {\n          callback(err);\n\n          callback = function callback() {};\n        } else {\n          index++;\n          results[position] = result;\n\n          if (index >= arr.length) {\n            callback(null, results);\n          }\n        }\n      });\n    });\n  },\n  linkBytecode: function linkBytecode(bytecode, links) {\n    Object.keys(links).forEach(function (library_name) {\n      var library_address = links[library_name];\n      var regex = new RegExp(\"__\" + library_name + \"_+\", \"g\");\n      bytecode = bytecode.replace(regex, library_address.replace(\"0x\", \"\"));\n    });\n    return bytecode;\n  },\n  // Extracts optional tx params from a list of fn arguments\n  getTxParams: function getTxParams(args) {\n    var constructor = this;\n    var tx_params = {};\n    var last_arg = args[args.length - 1]; // It's only tx_params if it's an object and not a BigNumber.\n\n    if (Utils.is_object(last_arg) && !Utils.is_big_number(last_arg)) {\n      tx_params = args.pop();\n    }\n\n    tx_params = Utils.merge(constructor.class_defaults, tx_params);\n    return tx_params;\n  },\n  // Verifies that a contracts libraries have been linked correctly.\n  // Throws on error\n  checkLibraries: function checkLibraries() {\n    var constructor = this;\n    var regex = /__[^_]+_+/g;\n    var unlinked_libraries = constructor.binary.match(regex);\n\n    if (unlinked_libraries != null) {\n      unlinked_libraries = unlinked_libraries.map(function (name) {\n        // Remove underscores\n        return name.replace(/_/g, \"\");\n      }).sort().filter(function (name, index, arr) {\n        // Remove duplicates\n        if (index + 1 >= arr.length) {\n          return true;\n        }\n\n        return name != arr[index + 1];\n      }).join(\", \");\n      var error = constructor.contractName + \" contains unresolved libraries. You must deploy and link\" + \" the following libraries before you can deploy a new version of \" + constructor.contractName + \": \" + unlinked_libraries;\n      throw new Error(error);\n    }\n  }\n};\nmodule.exports = Utils;","map":null,"metadata":{},"sourceType":"script"}