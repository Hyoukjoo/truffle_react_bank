{"ast":null,"code":"var BlockchainUtils = require(\"truffle-blockchain-utils\");\n\nvar Web3 = require(\"web3\");\n\nvar Web3PromiEvent = require('web3-core-promievent');\n\nvar webUtils = require('web3-utils');\n\nvar StatusError = require(\"./statuserror\");\n\nvar utils = require(\"./utils\");\n\nvar execute = require(\"./execute\");\n\nvar handle = require(\"./handlers\"); // For browserified version. If browserify gave us an empty version,\n// look for the one provided by the user.\n\n\nif (typeof Web3 == \"object\" && Object.keys(Web3).length == 0) {\n  Web3 = global.Web3;\n}\n\nvar contract = function (module) {\n  // Accepts a contract object created with web3.eth.Contract or an address.\n  function Contract(contract) {\n    var instance = this;\n    var constructor = instance.constructor; // Disambiguate between .at() and .new()\n\n    if (typeof contract == \"string\") {\n      var web3Instance = new constructor.web3.eth.Contract(constructor.abi);\n      web3Instance.options.address = contract;\n      contract = web3Instance;\n    } // Core:\n\n\n    instance.methods = {};\n    instance.abi = constructor.abi;\n    instance.address = contract.options.address;\n    instance.transactionHash = contract.transactionHash;\n    instance.contract = contract; // User defined methods, overloaded methods, events\n\n    instance.abi.forEach(function (item) {\n      switch (item.type) {\n        case \"function\":\n          var isConstant = [\"pure\", \"view\"].includes(item.stateMutability) || // new form\n          item.constant; // deprecated case\n\n          var signature = webUtils._jsonInterfaceMethodToString(item);\n\n          var method = function method(constant, web3Method) {\n            var fn;\n            constant ? fn = execute.call.call(constructor, web3Method, item, instance.address) : fn = execute.send.call(constructor, web3Method, instance.address);\n            fn.call = execute.call.call(constructor, web3Method, item, instance.address);\n            fn.sendTransaction = execute.send.call(constructor, web3Method, instance.address);\n            fn.estimateGas = execute.estimate.call(constructor, web3Method, instance.address);\n            fn.request = execute.request.call(constructor, web3Method, instance.address);\n            return fn;\n          }; // Only define methods once. Any overloaded methods will have all their\n          // accessors available by ABI signature available on the `methods` key below.\n\n\n          if (instance[item.name] === undefined) {\n            instance[item.name] = method(isConstant, contract.methods[item.name]);\n          } // Overloaded methods should be invoked via the .methods property\n\n\n          instance.methods[signature] = method(isConstant, contract.methods[signature]);\n          break;\n\n        case \"event\":\n          instance[item.name] = execute.event.call(constructor, contract.events[item.name]);\n          break;\n      }\n    }); // sendTransaction / send\n\n    instance.sendTransaction = execute.send.call(constructor, null, instance.address); // Prefer user defined `send`\n\n    if (!instance.send) {\n      instance.send = function (value) {\n        var txParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var packet = Object.assign({\n          value: value\n        }, txParams);\n        return instance.sendTransaction(packet);\n      };\n    } // Other events\n\n\n    instance.allEvents = execute.allEvents.call(constructor, contract);\n    instance.getPastEvents = execute.getPastEvents.call(constructor, contract);\n  }\n\n  ;\n  Contract._constructorMethods = {\n    setProvider: function setProvider(provider) {\n      if (!provider) {\n        throw new Error(\"Invalid provider passed to setProvider(); provider is \" + provider);\n      }\n\n      this.web3.setProvider(provider);\n      this.currentProvider = provider;\n    },\n    new: function _new() {\n      var constructor = this;\n      var promiEvent = new Web3PromiEvent();\n\n      if (!constructor.currentProvider) {\n        var err = constructor.contractName + \" error: Please call setProvider() first before calling new().\";\n        throw new Error(err);\n      }\n\n      if (!constructor.bytecode || constructor.bytecode === \"0x\") {\n        var err = \"\".concat(constructor.contractName, \" error: contract binary not set. Can't deploy new instance.\\n\") + \"This contract may be abstract, not implement an abstract parent's methods completely\\n\" + \"or not invoke an inherited contract's constructor correctly\\n\";\n        throw new Error(err);\n      }\n\n      var args = Array.prototype.slice.call(arguments); // Promievent and flag that allows instance to resolve (rather than just receipt)\n\n      var context = {\n        contract: constructor,\n        promiEvent: promiEvent,\n        onlyEmitReceipt: true\n      };\n      constructor.detectNetwork().then(function (network) {\n        utils.checkLibraries.apply(constructor);\n        return execute.deploy.call(constructor, args, context, network.blockLimit);\n      }).catch(promiEvent.reject);\n      return promiEvent.eventEmitter;\n    },\n    at: function at(address) {\n      var constructor = this;\n      return new Promise(function (accept, reject) {\n        if (address == null || typeof address != \"string\" || address.length != 42) {\n          var err = \"Invalid address passed to \" + constructor.contractName + \".at(): \" + address;\n          reject(new Error(err));\n        }\n\n        return constructor.detectNetwork().then(function (network_id) {\n          var instance = new constructor(address);\n          return constructor.web3.eth.getCode(address).then(function (code) {\n            if (!code || code.replace(\"0x\", \"\").replace(/0/g, \"\") === '') {\n              var err = \"Cannot create instance of \" + constructor.contractName + \"; no code at address \" + address;\n              reject(new Error(err));\n            }\n\n            accept(instance);\n          });\n        });\n      });\n    },\n    deployed: function deployed() {\n      var constructor = this;\n      return constructor.detectNetwork().then(function () {\n        // We don't have a network config for the one we found\n        if (constructor._json.networks[constructor.network_id] == null) {\n          var error = constructor.contractName + \" has not been deployed to detected network\" + \" (network/artifact mismatch)\";\n          throw new Error(error);\n        } // If we found the network but it's not deployed\n\n\n        if (!constructor.isDeployed()) {\n          var error = constructor.contractName + \" has not been deployed to detected network (\" + constructor.network_id + \")\";\n          throw new Error(error);\n        }\n\n        return new constructor(constructor.address);\n      });\n    },\n    defaults: function defaults(class_defaults) {\n      if (this.class_defaults == null) {\n        this.class_defaults = {};\n      }\n\n      if (class_defaults == null) {\n        class_defaults = {};\n      }\n\n      var constructor = this;\n      Object.keys(class_defaults).forEach(function (key) {\n        var value = class_defaults[key];\n        constructor.class_defaults[key] = value;\n      });\n      return this.class_defaults;\n    },\n    hasNetwork: function hasNetwork(network_id) {\n      return this._json.networks[network_id + \"\"] != null;\n    },\n    isDeployed: function isDeployed() {\n      if (this.network_id == null) {\n        return false;\n      }\n\n      if (this._json.networks[this.network_id] == null) {\n        return false;\n      }\n\n      return !!this.network.address;\n    },\n    detectNetwork: function detectNetwork() {\n      var constructor = this;\n      return new Promise(function (accept, reject) {\n        // Try to get the current blockLimit\n        constructor.web3.eth.getBlock('latest').then(function (block) {\n          // Try to detect the network we have artifacts for.\n          if (constructor.network_id) {\n            // We have a network id and a configuration, let's go with it.\n            if (constructor.networks[constructor.network_id] != null) {\n              return accept({\n                id: constructor.network_id,\n                blockLimit: block.gasLimit\n              });\n            }\n          }\n\n          constructor.web3.eth.net.getId().then(function (network_id) {\n            // If we found the network via a number, let's use that.\n            if (constructor.hasNetwork(network_id)) {\n              constructor.setNetwork(network_id);\n              return accept({\n                id: constructor.network_id,\n                blockLimit: block.gasLimit\n              });\n            } // Otherwise, go through all the networks that are listed as\n            // blockchain uris and see if they match.\n\n\n            var uris = Object.keys(constructor._json.networks).filter(function (network) {\n              return network.indexOf(\"blockchain://\") == 0;\n            });\n            var matches = uris.map(function (uri) {\n              return BlockchainUtils.matches.bind(BlockchainUtils, uri, constructor.web3.currentProvider);\n            });\n            utils.parallel(matches, function (err, results) {\n              if (err) return reject(err);\n\n              for (var i = 0; i < results.length; i++) {\n                if (results[i]) {\n                  constructor.setNetwork(uris[i]);\n                  return accept({\n                    id: constructor.network_id,\n                    blockLimit: block.gasLimit\n                  });\n                }\n              } // We found nothing. Set the network id to whatever the provider states.\n\n\n              constructor.setNetwork(network_id);\n              return accept({\n                id: constructor.network_id,\n                blockLimit: block.gasLimit\n              });\n            });\n          }).catch(reject);\n        }).catch(reject);\n      });\n    },\n    setNetwork: function setNetwork(network_id) {\n      if (!network_id) return;\n      this.network_id = network_id + \"\";\n    },\n    setWallet: function setWallet(wallet) {\n      this.web3.eth.accounts.wallet = wallet;\n    },\n    // Overrides the deployed address to null.\n    // You must call this explicitly so you don't inadvertently do this otherwise.\n    resetAddress: function resetAddress() {\n      delete this.network.address;\n    },\n    link: function link(name, address) {\n      var constructor = this; // Case: Contract.link(instance)\n\n      if (typeof name == \"function\") {\n        var contract = name;\n\n        if (contract.isDeployed() == false) {\n          throw new Error(\"Cannot link contract without an address.\");\n        }\n\n        this.link(contract.contractName, contract.address); // Merge events so this contract knows about library's events\n\n        Object.keys(contract.events).forEach(function (topic) {\n          constructor.network.events[topic] = contract.events[topic];\n        });\n        return;\n      } // Case: Contract.link({<libraryName>: <address>, ... })\n\n\n      if (typeof name == \"object\") {\n        var obj = name;\n        Object.keys(obj).forEach(function (name) {\n          var a = obj[name];\n          constructor.link(name, a);\n        });\n        return;\n      } // Case: Contract.link(<libraryName>, <address>)\n\n\n      if (this._json.networks[this.network_id] == null) {\n        this._json.networks[this.network_id] = {\n          events: {},\n          links: {}\n        };\n      }\n\n      this.network.links[name] = address;\n    },\n    // Note, this function can be called with two input types:\n    // 1. Object with a bunch of data; this data will be merged with the json data of contract being cloned.\n    // 2. network id; this will clone the contract and set a specific network id upon cloning.\n    clone: function clone(json) {\n      var constructor = this;\n      json = json || {};\n\n      var temp = function TruffleContract() {\n        this.constructor = temp;\n        return Contract.apply(this, arguments);\n      };\n\n      temp.prototype = Object.create(constructor.prototype);\n      var network_id; // If we have a network id passed\n\n      if (typeof json != \"object\") {\n        network_id = json;\n        json = constructor._json;\n      }\n\n      json = utils.merge({}, constructor._json || {}, json);\n      temp._constructorMethods = this._constructorMethods;\n      temp._properties = this._properties;\n      temp._property_values = {};\n      temp._json = json;\n      bootstrap(temp);\n      temp.web3 = new Web3();\n      temp.class_defaults = temp.prototype.defaults || {};\n\n      if (network_id) {\n        temp.setNetwork(network_id);\n      } // Copy over custom key/values to the contract class\n\n\n      Object.keys(json).forEach(function (key) {\n        if (key.indexOf(\"x-\") != 0) return;\n        temp[key] = json[key];\n      });\n      return temp;\n    },\n    addProp: function addProp(key, fn) {\n      var constructor = this;\n\n      var getter = function getter() {\n        if (fn.get != null) {\n          return fn.get.call(constructor);\n        }\n\n        return constructor._property_values[key] || fn.call(constructor);\n      };\n\n      var setter = function setter(val) {\n        if (fn.set != null) {\n          fn.set.call(constructor, val);\n          return;\n        } // If there's not a setter, then the property is immutable.\n\n\n        throw new Error(key + \" property is immutable\");\n      };\n\n      var definition = {};\n      definition.enumerable = false;\n      definition.configurable = false;\n      definition.get = getter;\n      definition.set = setter;\n      Object.defineProperty(this, key, definition);\n    },\n    toJSON: function toJSON() {\n      return this._json;\n    }\n  }; // Getter functions are scoped to Contract object.\n\n  Contract._properties = {\n    contract_name: {\n      get: function get() {\n        return this.contractName;\n      },\n      set: function set(val) {\n        this.contractName = val;\n      }\n    },\n    contractName: {\n      get: function get() {\n        return this._json.contractName || \"Contract\";\n      },\n      set: function set(val) {\n        this._json.contractName = val;\n      }\n    },\n    gasMultiplier: {\n      get: function get() {\n        if (this._json.gasMultiplier === undefined) {\n          this._json.gasMultiplier = 1.25;\n        }\n\n        return this._json.gasMultiplier;\n      },\n      set: function set(val) {\n        this._json.gasMultiplier = val;\n      }\n    },\n    timeoutBlocks: {\n      get: function get() {\n        return this._json.timeoutBlocks;\n      },\n      set: function set(val) {\n        this._json.timeoutBlocks = val;\n      }\n    },\n    autoGas: {\n      get: function get() {\n        if (this._json.autoGas === undefined) {\n          this._json.autoGas = true;\n        }\n\n        return this._json.autoGas;\n      },\n      set: function set(val) {\n        this._json.autoGas = val;\n      }\n    },\n    numberFormat: {\n      get: function get() {\n        if (this._json.numberFormat === undefined) {\n          this._json.numberFormat = 'BN';\n        }\n\n        return this._json.numberFormat;\n      },\n      set: function set(val) {\n        var allowedFormats = ['BigNumber', 'BN', 'String'];\n        var msg = \"Invalid number format setting: \\\"\".concat(val, \"\\\": \") + \"valid formats are: \".concat(JSON.stringify(allowedFormats), \".\");\n        if (!allowedFormats.includes(val)) throw new Error(msg);\n        this._json.numberFormat = val;\n      }\n    },\n    abi: {\n      get: function get() {\n        return this._json.abi;\n      },\n      set: function set(val) {\n        this._json.abi = val;\n      }\n    },\n    network: function network() {\n      var network_id = this.network_id;\n\n      if (network_id == null) {\n        var error = this.contractName + \" has no network id set, cannot lookup artifact data.\" + \" Either set the network manually using \" + this.contractName + \".setNetwork(), run \" + this.contractName + \".detectNetwork(), or use new(),\" + \" at() or deployed() as a thenable which will detect the network automatically.\";\n        throw new Error(error);\n      } // TODO: this might be bad; setting a value on a get.\n\n\n      if (this._json.networks[network_id] == null) {\n        var error = this.contractName + \" has no network configuration\" + \" for its current network id (\" + network_id + \").\";\n        throw new Error(error);\n      }\n\n      var returnVal = this._json.networks[network_id]; // Normalize output\n\n      if (returnVal.links == null) {\n        returnVal.links = {};\n      }\n\n      if (returnVal.events == null) {\n        returnVal.events = {};\n      }\n\n      return returnVal;\n    },\n    networks: function networks() {\n      return this._json.networks;\n    },\n    address: {\n      get: function get() {\n        var address = this.network.address;\n\n        if (address == null) {\n          var error = \"Cannot find deployed address: \" + this.contractName + \" not deployed or address not set.\";\n          throw new Error(error);\n        }\n\n        return address;\n      },\n      set: function set(val) {\n        if (val == null) {\n          throw new Error(\"Cannot set deployed address; malformed value: \" + val);\n        }\n\n        var network_id = this.network_id;\n\n        if (network_id == null) {\n          var error = this.contractName + \" has no network id set, cannot lookup artifact data.\" + \" Either set the network manually using \" + this.contractName + \".setNetwork(), run \" + this.contractName + \".detectNetwork(),\" + \" or use new(), at() or deployed() as a thenable which will\" + \" detect the network automatically.\";\n          throw new Error(error);\n        } // Create a network if we don't have one.\n\n\n        if (this._json.networks[network_id] == null) {\n          this._json.networks[network_id] = {\n            events: {},\n            links: {}\n          };\n        } // Finally, set the address.\n\n\n        this.network.address = val;\n      }\n    },\n    transactionHash: {\n      get: function get() {\n        return this.network.transactionHash;\n      },\n      set: function set(val) {\n        this.network.transactionHash = val;\n      }\n    },\n    links: function links() {\n      if (!this.network_id) {\n        var error = this.contractName + \" has no network id set, cannot lookup artifact data.\" + \" Either set the network manually using \" + this.contractName + \".setNetwork(),\" + \" run \" + this.contractName + \".detectNetwork(), or use new(), at()\" + \" or deployed() as a thenable which will detect the network automatically.\";\n        throw new Error(error);\n      }\n\n      if (this._json.networks[this.network_id] == null) {\n        return {};\n      }\n\n      return this.network.links || {};\n    },\n    events: function events() {\n      // helper web3; not used for provider\n      var web3 = new Web3();\n      var events;\n\n      if (this._json.networks[this.network_id] == null) {\n        events = {};\n      } else {\n        events = this.network.events || {};\n      } // Merge abi events with whatever's returned.\n\n\n      var abi = this.abi;\n      abi.forEach(function (item) {\n        if (item.type != \"event\") return;\n        var signature = item.name + \"(\";\n        item.inputs.forEach(function (input, index) {\n          signature += input.type;\n\n          if (index < item.inputs.length - 1) {\n            signature += \",\";\n          }\n        });\n        signature += \")\";\n        var topic = web3.utils.keccak256(signature);\n        events[topic] = item;\n      });\n      return events;\n    },\n    binary: function binary() {\n      return utils.linkBytecode(this.bytecode, this.links);\n    },\n    deployedBinary: function deployedBinary() {\n      return utils.linkBytecode(this.deployedBytecode, this.links);\n    },\n    // deprecated; use bytecode\n    unlinked_binary: {\n      get: function get() {\n        return this.bytecode;\n      },\n      set: function set(val) {\n        this.bytecode = val;\n      }\n    },\n    // alias for unlinked_binary; unlinked_binary will eventually be deprecated\n    bytecode: {\n      get: function get() {\n        return this._json.bytecode;\n      },\n      set: function set(val) {\n        this._json.bytecode = val;\n      }\n    },\n    deployedBytecode: {\n      get: function get() {\n        var code = this._json.deployedBytecode;\n\n        if (code.indexOf(\"0x\") != 0) {\n          code = \"0x\" + code;\n        }\n\n        return code;\n      },\n      set: function set(val) {\n        var code = val;\n\n        if (val.indexOf(\"0x\") != 0) {\n          code = \"0x\" + code;\n        }\n\n        this._json.deployedBytecode = code;\n      }\n    },\n    sourceMap: {\n      get: function get() {\n        return this._json.sourceMap;\n      },\n      set: function set(val) {\n        this._json.sourceMap = val;\n      }\n    },\n    deployedSourceMap: {\n      get: function get() {\n        return this._json.deployedSourceMap;\n      },\n      set: function set(val) {\n        this._json.deployedSourceMap = val;\n      }\n    },\n    source: {\n      get: function get() {\n        return this._json.source;\n      },\n      set: function set(val) {\n        this._json.source = val;\n      }\n    },\n    sourcePath: {\n      get: function get() {\n        return this._json.sourcePath;\n      },\n      set: function set(val) {\n        this._json.sourcePath = val;\n      }\n    },\n    legacyAST: {\n      get: function get() {\n        return this._json.legacyAST;\n      },\n      set: function set(val) {\n        this._json.legacyAST = val;\n      }\n    },\n    ast: {\n      get: function get() {\n        return this._json.ast;\n      },\n      set: function set(val) {\n        this._json.ast = val;\n      }\n    },\n    compiler: {\n      get: function get() {\n        return this._json.compiler;\n      },\n      set: function set(val) {\n        this._json.compiler = val;\n      }\n    },\n    // Deprecated\n    schema_version: function schema_version() {\n      return this.schemaVersion;\n    },\n    schemaVersion: function schemaVersion() {\n      return this._json.schemaVersion;\n    },\n    // deprecated\n    updated_at: function updated_at() {\n      return this.updatedAt;\n    },\n    updatedAt: function updatedAt() {\n      try {\n        return this.network.updatedAt || this._json.updatedAt;\n      } catch (e) {\n        return this._json.updatedAt;\n      }\n    }\n  };\n\n  function bootstrap(fn) {\n    // Add our static methods\n    // Add something here about excluding send, privately defined methods\n    Object.keys(fn._constructorMethods).forEach(function (key) {\n      fn[key] = fn._constructorMethods[key].bind(fn);\n    }); // Add our properties.\n\n    Object.keys(fn._properties).forEach(function (key) {\n      fn.addProp(key, fn._properties[key]);\n    }); // estimateGas as sub-property of new\n\n    fn['new'].estimateGas = execute.estimateDeployment.bind(fn);\n    return fn;\n  }\n\n  ;\n  bootstrap(Contract);\n  module.exports = Contract;\n  return Contract;\n}(module || {});","map":null,"metadata":{},"sourceType":"script"}