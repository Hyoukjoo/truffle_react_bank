{"ast":null,"code":"var _regeneratorRuntime = require(\"c:\\\\Users\\\\judam\\\\Documents\\\\HJ\\\\dev\\\\truffle_react\\\\client\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _toConsumableArray = require(\"c:\\\\Users\\\\judam\\\\Documents\\\\HJ\\\\dev\\\\truffle_react\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _asyncToGenerator = require(\"c:\\\\Users\\\\judam\\\\Documents\\\\HJ\\\\dev\\\\truffle_react\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar Web3PromiEvent = require('web3-core-promievent');\n\nvar EventEmitter = require('events');\n\nvar utils = require(\"./utils\");\n\nvar StatusError = require(\"./statuserror\");\n\nvar Reason = require(\"./reason\");\n\nvar handlers = require(\"./handlers\");\n\nvar override = require(\"./override\");\n\nvar reformat = require(\"./reformat\");\n\nvar util = require('util');\n\nvar execute = {\n  // -----------------------------------  Helpers --------------------------------------------------\n\n  /**\n   * Retrieves gas estimate multiplied by the set gas multiplier for a `sendTransaction` call.\n   * @param  {Object} params     `sendTransaction` parameters\n   * @param  {Number} blockLimit  most recent network block.blockLimit\n   * @return {Number}             gas estimate\n   */\n  getGasEstimate: function getGasEstimate(params, blockLimit) {\n    var constructor = this;\n    var web3 = this.web3;\n    return new Promise(function (accept, reject) {\n      // Always prefer specified gas - this includes gas set by class_defaults\n      if (params.gas) return accept(params.gas);\n      if (!constructor.autoGas) return accept();\n      web3.eth.estimateGas(params).then(function (gas) {\n        var bestEstimate = Math.floor(constructor.gasMultiplier * gas); // Don't go over blockLimit\n\n        bestEstimate >= blockLimit ? accept(blockLimit - 1) : accept(bestEstimate); // We need to let txs that revert through.\n        // Often that's exactly what you are testing.\n      }).catch(function (err) {\n        return accept();\n      });\n    });\n  },\n\n  /**\n   * Prepares simple wrapped calls by checking network and organizing the method inputs into\n   * objects web3 can consume.\n   * @param  {Object} constructor   TruffleContract constructor\n   * @param  {Array}  _arguments    Arguments passed to method invocation\n   * @return {Promise}              Resolves object w/ tx params disambiguated from arguments\n   */\n  prepareCall: function prepareCall(constructor, _arguments) {\n    var args = Array.prototype.slice.call(_arguments);\n    var params = utils.getTxParams.call(constructor, args);\n    return constructor.detectNetwork().then(function () {\n      return {\n        args: args,\n        params: params\n      };\n    });\n  },\n\n  /**\n   * Disambiguates between transaction parameter objects and BN / BigNumber objects\n   * @param  {Any}  arg\n   * @return {Boolean}\n   */\n  hasTxParams: function hasTxParams(arg) {\n    return utils.is_object(arg) && !utils.is_big_number(arg);\n  },\n\n  /**\n   * Parses function arguments to discover if the terminal argument specifies the `defaultBlock`\n   * to execute a call at.\n   * @param  {Array}  args      `arguments` that were passed to method\n   * @param  {Any}    lastArg    terminal argument passed to method\n   * @param  {Array}  inputs     ABI segment defining method arguments\n   * @return {Boolean}           true if final argument is `defaultBlock`\n   */\n  hasDefaultBlock: function hasDefaultBlock(args, lastArg, inputs) {\n    var hasDefaultBlock = !execute.hasTxParams(lastArg) && args.length > inputs.length;\n    var hasDefaultBlockWithParams = execute.hasTxParams(lastArg) && args.length - 1 > inputs.length;\n    return hasDefaultBlock || hasDefaultBlockWithParams;\n  },\n  // -----------------------------------  Methods --------------------------------------------------\n\n  /**\n   * Executes method as .call and processes optional `defaultBlock` argument.\n   * @param  {Function} fn         method\n   * @param  {Object}   methodABI  function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}             Return value of the call.\n   */\n  call: function call(fn, methodABI, address) {\n    var constructor = this;\n    return function () {\n      var params = {};\n      var defaultBlock = 'latest';\n      var args = Array.prototype.slice.call(arguments);\n      var lastArg = args[args.length - 1]; // Extract defaultBlock parameter\n\n      if (execute.hasDefaultBlock(args, lastArg, methodABI.inputs)) {\n        defaultBlock = args.pop();\n      } // Extract tx params\n\n\n      if (execute.hasTxParams(lastArg)) {\n        params = args.pop();\n      }\n\n      params.to = address;\n      params = utils.merge(constructor.class_defaults, params);\n      return new Promise(\n      /*#__PURE__*/\n      function () {\n        var _ref = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee(resolve, reject) {\n          var result;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  _context.next = 3;\n                  return constructor.detectNetwork();\n\n                case 3:\n                  _context.next = 5;\n                  return fn.apply(void 0, _toConsumableArray(args)).call(params, defaultBlock);\n\n                case 5:\n                  result = _context.sent;\n                  result = reformat.numbers.call(constructor, result, methodABI.outputs);\n                  resolve(result);\n                  _context.next = 13;\n                  break;\n\n                case 10:\n                  _context.prev = 10;\n                  _context.t0 = _context[\"catch\"](0);\n                  reject(_context.t0);\n\n                case 13:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this, [[0, 10]]);\n        }));\n\n        return function (_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    };\n  },\n\n  /**\n   * Executes method as .send\n   * @param  {Function}   fn       Method to invoke\n   * @param  {String}     address  Deployed address of the targeted instance\n   * @return {PromiEvent}          Resolves a transaction receipt (via the receipt handler)\n   */\n  send: function send(fn, address) {\n    var constructor = this;\n    var web3 = constructor.web3;\n    return function () {\n      var deferred;\n      var args = Array.prototype.slice.call(arguments);\n      var params = utils.getTxParams.call(constructor, args);\n      var promiEvent = new Web3PromiEvent();\n      var context = {\n        contract: constructor,\n        // Can't name this field `constructor` or `_constructor`\n        promiEvent: promiEvent,\n        params: params\n      };\n      constructor.detectNetwork().then(function (network) {\n        params.to = address;\n        params.data = fn ? fn.apply(void 0, _toConsumableArray(args)).encodeABI() : undefined;\n        execute.getGasEstimate.call(constructor, params, network.blockLimit).then(function (gas) {\n          params.gas = gas;\n          deferred = web3.eth.sendTransaction(params);\n          deferred.catch(override.start.bind(constructor, context));\n          handlers.setup(deferred, context);\n        }).catch(promiEvent.reject);\n      }).catch(promiEvent.reject);\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Deploys an instance. Network detection for `.new` happens before invocation at `contract.js`\n   * where we check the libraries.\n   * @param  {Object} args        Deployment options;\n   * @param  {Object} context     Context object that exposes execution state to event handlers.\n   * @param  {Number} blockLimit  `block.gasLimit`\n   * @return {PromiEvent}         Resolves a TruffleContract instance\n  */\n  deploy: function deploy(args, context, blockLimit) {\n    var constructor = this;\n    var abi = constructor.abi;\n    var web3 = constructor.web3;\n    var params = utils.getTxParams.call(constructor, args);\n    var deferred;\n    var options = {\n      data: constructor.binary,\n      arguments: args\n    };\n    var contract = new web3.eth.Contract(abi);\n    params.data = contract.deploy(options).encodeABI();\n    execute.getGasEstimate.call(constructor, params, blockLimit).then(function (gas) {\n      params.gas = gas;\n      context.params = params;\n      deferred = web3.eth.sendTransaction(params);\n      handlers.setup(deferred, context);\n      deferred.then(\n      /*#__PURE__*/\n      function () {\n        var _ref2 = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee2(receipt) {\n          var reason, error, web3Instance;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (!(receipt.status !== undefined && !receipt.status)) {\n                    _context2.next = 6;\n                    break;\n                  }\n\n                  _context2.next = 3;\n                  return Reason.get(params, web3);\n\n                case 3:\n                  reason = _context2.sent;\n                  error = new StatusError(params, context.transactionHash, receipt, reason);\n                  return _context2.abrupt(\"return\", context.promiEvent.reject(error));\n\n                case 6:\n                  web3Instance = new web3.eth.Contract(abi, receipt.contractAddress);\n                  web3Instance.transactionHash = context.transactionHash;\n                  context.promiEvent.resolve(new constructor(web3Instance)); // Manage web3's 50 blocks' timeout error.\n                  // Web3's own subscriptions go dead here.\n\n                case 9:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        return function (_x3) {\n          return _ref2.apply(this, arguments);\n        };\n      }()).catch(override.start.bind(constructor, context));\n    }).catch(context.promiEvent.reject);\n  },\n\n  /**\n   * Begins listening for an event OR manages the event callback\n   * @param  {Function} fn  Solidity event method\n   * @return {Emitter}      Event emitter\n   */\n  event: function event(fn) {\n    var constructor = this;\n    var decode = utils.decodeLogs;\n    var currentLogID = null; // Someone upstream is firing duplicates :/\n\n    function dedupe(id) {\n      return id === currentLogID ? false : currentLogID = id;\n    }\n\n    return function (params, callback) {\n      if (typeof params == \"function\") {\n        callback = params;\n        params = {};\n      } // As callback\n\n\n      if (callback !== undefined) {\n        var intermediary = function intermediary(err, e) {\n          if (err) callback(err);\n          var event = dedupe(e.id) && decode.call(constructor, e, true)[0];\n          callback(null, event);\n        };\n\n        return constructor.detectNetwork().then(function () {\n          return fn.call(constructor.events, params, intermediary);\n        });\n      } // As EventEmitter\n\n\n      var emitter = new EventEmitter();\n      constructor.detectNetwork().then(function () {\n        var event = fn(params);\n        event.on('data', function (e) {\n          return dedupe(e.id) && emitter.emit('data', decode.call(constructor, e, true)[0]);\n        });\n        event.on('changed', function (e) {\n          return dedupe(e.id) && emitter.emit('changed', decode.call(constructor, e, true)[0]);\n        });\n        event.on('error', function (e) {\n          return emitter.emit('error', e);\n        });\n      });\n      return emitter;\n    };\n  },\n\n  /**\n   * Wraps web3 `allEvents`, with additional log decoding\n   * @return {PromiEvent}  EventEmitter\n   */\n  allEvents: function allEvents(web3Instance) {\n    var constructor = this;\n    var decode = utils.decodeLogs;\n    var currentLogID = null; // Someone upstream is firing duplicates :/\n\n    function dedupe(id) {\n      return id === currentLogID ? false : currentLogID = id;\n    }\n\n    return function (params) {\n      var emitter = new EventEmitter();\n      constructor.detectNetwork().then(function () {\n        var event = web3Instance.events.allEvents(params);\n        event.on('data', function (e) {\n          return dedupe(e.id) && emitter.emit('data', decode.call(constructor, e, true)[0]);\n        });\n        event.on('changed', function (e) {\n          return dedupe(e.id) && emitter.emit('changed', decode.call(constructor, e, true)[0]);\n        });\n        event.on('error', function (e) {\n          return emitter.emit('error', e);\n        });\n      });\n      return emitter;\n    };\n  },\n\n  /**\n   * Wraps web3 `getPastEvents`, with additional log decoding\n   * @return {Promise}  Resolves array of event objects\n   */\n  getPastEvents: function getPastEvents(web3Instance) {\n    var constructor = this;\n    var decode = utils.decodeLogs;\n    return function (event, options) {\n      return web3Instance.getPastEvents(event, options).then(function (events) {\n        return decode.call(constructor, events, false);\n      });\n    };\n  },\n\n  /**\n   * Estimates gas cost of a method invocation\n   * @param  {Function} fn  Method to target\n   * @return {Promise}\n   */\n  estimate: function estimate(fn) {\n    var constructor = this;\n    return function () {\n      return execute.prepareCall(constructor, arguments).then(function (res) {\n        return fn.apply(void 0, _toConsumableArray(res.args)).estimateGas(res.params);\n      });\n    };\n  },\n  request: function request(fn) {\n    var constructor = this;\n    return function () {\n      return execute.prepareCall(constructor, arguments).then(function (res) {\n        return fn.apply(void 0, _toConsumableArray(res.args)).request(res.params);\n      });\n    };\n  },\n  // This gets attached to `.new` (declared as a static_method in `contract`)\n  // during bootstrapping as `estimate`\n  estimateDeployment: function estimateDeployment() {\n    var constructor = this;\n    return execute.prepareCall(constructor, arguments).then(function (res) {\n      var options = {\n        data: constructor.binary,\n        arguments: res.args\n      };\n      delete res.params['data']; // Is this necessary?\n\n      var instance = new constructor.web3.eth.Contract(constructor.abi, res.params);\n      return instance.deploy(options).estimateGas(res.params);\n    });\n  }\n};\nmodule.exports = execute;","map":null,"metadata":{},"sourceType":"script"}